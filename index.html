<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
          
    <title>Lecture</title>
  </head>
  <body>
    <h1>Lecture</h1>
    <p>
      thank you all right thank you foreign beautiful all right welcome uh good morning so let's uh get started with the business of the day and The Business of the day is serious because we're going to be wrapping up the proof of this thing that we spoke about the last time which is uh Cook's theorem yeah and so let me just start with a quick recap of some of the important Concepts that we've seen so far and that will also continue to play an important role in the rest of this module um so we're looking at what kinds of decision problems or languages have efficient algorithms and in general we are interested in this large class of decision problems that we called NP so NP refers to uh all languages that have efficient verification procedures so that's how NP is defined and what that means is that a given string X is in the language exactly when there is a short witness why that kind of convinces you that X is in the language so L Prime is this verification procedure and X is another language if and only if there is a short y the length of Y is bounded by a polynomial function of the length of X such as the pair X Y can be seen to be in the verification language yeah and it's important that this verification procedure L Prime is polynomial time so that's the definition of NP and what we're doing uh what we've what our aim is in this uh in this kind of module is to kind of organize the languages in NP the decision problems in NP organize them in some sort of hierarchy and this hierarchy is defined by this notion of a reduction so where we say that L1 reduces to L2 if there is an efficiently computable map r that converts the problem of checking if a string is in L1 to checking if some corresponding string R of X is in L2 right so that's what a reduction means and intuitively what this is saying is that L1 is at most as hard as L2 in a computational sense and the languages in NP are said to be NP I'm sorry language is not necessarily in NP but a language is said to be NP hard if every language in NP is at most as hard as this language so those are the NP hard languages sort of harder than everything in NP and the language is NP complete if it's both in NP and NP hard at the same time so these are the hardest languages in NP and in particular P equals NP if and only if you can find an efficient algorithm for one of these NP complete languages yeah so in this sense it's very useful to have an NP complete language uh but so far we haven't really seen examples of an NP complete language and the main aim of this lecture is to finally construct an example of an NP complete language okay to show uh mathematically that a certain problem is can be complete yeah and what is this problem so we spoke about it last time already is this this is the Boolean satisfiability problem so uh the problem I'm going to recall it on the next slide but the problem is uh the the question of checking if a Boolean formula given as a CNF formula uh is satisfiable so if you can set its variables to set it to make the formula output true or one right and this problem was introduced in this uh Landmark paper by Steve Cook so it's called Cook's theorem so he showed that this problem is an NP which is a fairly easy observation and but more importantly he showed that this problem is NP hard so every language in NP no matter what language it is reduces to this language in polynomial time and this is one we want to see today that satis and be hard and putting these two thoughts together you see that sat is both in NP and NP hard and therefore it's NP complete so that's going to be the main goal okay and so just to recall so what is the definition of sand so you're given a Boolean function right and just to recall so a Boolean function is something that takes a bunch of Boolean variables each of them zero or one so I Boolean it takes these variables as input and it spits out one value which is either zero or one right so it takes a bunch of variables insert value and in in this problem the problem of satisfiability you're given this Boolean function in a very specific form in so-called CNF representation and what is a CNF representation or a CNF Boolean formula well it's a formula that looks like the examples that are given in the slide here so the formula is an and of things right so there's it's a giant and of things and each of the things are what are called Clauses so you have a bunch of Clauses uh so what is a clause a clause is just an R of literals and what's a literal a literal is either a variable or a variable with a not gate in front so that's a little right so you have literals and then you have Clauses which are odds of literals and the CNF formula is an and of clauses so given an assignment to these variables of the CNF formula the formula says one if all the Clauses are satisfied so it kind of checks if each of the Clause is satisfied and if all the Clause are satisfied since one and otherwise it says zero and the question is given a CNF uh is there an assignment to these underlying variables that makes that satisfies all the Clauses that makes the CNF say one okay a true and so this is the CNF satisfiability question so the last time we kind of uh just recalled or went through some basic facts about cnfs and they will sort of be useful in this lecture as well so it might be worth kind of recalling some of these facts so let's just do that with a short kind of a multimeter quiz so uh I'd like you to go to this place and so in this question you're asked to recall a certain uh algorithm that we well algorithm or procedure that we described the last time which allows us to represent any Boolean function as a CNF right so you're given a Boolean function and I've given it by its table or truth table here now I want you to represent this Clause as you see enough using the algorithm from last time and then tell me a little bit about the CNF that you constructed how many Clauses does it have so oh okay so the number of answers seems to have stabilized somewhat so let's let's see what you have to say oh wow okay unanimity perfect yes and the answer is absolutely right so the CNF indeed has four Clauses and let's just quickly Recall why so what we said the last time was what we're going to do is we're going to look at the table and for every zero of the table we're going to come up with a clause that rejects exactly that input and accepts everything else and then we're going to take the and of such Clauses so so for the the first zero here we come up with a clause which is I guess X1 or X2 or X3 so that's the uh that's the Clause corresponding that the Clause that rejects the first input and then accepts all the others and then you do something similar here and here in here so let's just write it down so we take this and let's write on the next input so that's going to be X1 or not X2 or X3 and uh what is it not X1 or X2 or not X3 and not x one or not x 2 or not X 3. okay so perfect you're all absolutely correct so there are four Clauses in the C and F okay so it turns out that the CNF also has a different representation with fewer than four Clauses so you can think about it but it's not immediately clear by just looking at the table okay so you can always do this right given any Boolean function you can always come up with a CNF representation of this form and in general the number of Clauses is going to be the number of zeros in the truth table and on a function with n variables that could be as many as 2 to the N right you could have lots and lots of zeros right but usually we'll employ this construction when the function is relatively small like on three or four bits and in that case the CNF representation only has constant size all right so I also mentioned this fact the last time though I didn't do any examples but you can do an analogous construction for dnfs right for a formulas in dnf representation and what's a dnf again so instead of Clauses you have things like terms terms or angles of literals and instead of having an and of you know Clauses you have an R of terms so that's a dnf right so it's a it's kind of the the roles of and and R are reversed when you go from CNF to dnf so suppose we look at the same Boolean function but we do this construction for dnfs instead of cnfs right how many terms would we get to kind of be a quick thing from what you've done already so I see that there are not as many answers as the last time maybe the question is somewhat unclear so we'll let's look at the answers and then maybe I'll describe I'll say a little bit more so I see a few more coming in right okay so let's see all right okay so everybody who has answered agrees that there are four terms okay except one all right so there's one dissenter um so um and indeed the answer is that there are four terms in the dnf and so so what's the analogous construction right it's exactly the same except that we flip the roles of zeros and ones so for every uh Row in the truth table that's a one we construct a term that has a one exactly in this location and is zero everywhere else right so for instance for this row here we would construct a term so now recall again a term is an and of literals so I would say in this case that not x one and not x two and X3 right so not x one and not x 2 and x three now the only way to satisfy this term to set this term to 1 is to set x 1 to 0 right X2 to 0 and X3 to 1. so that would correspond to this row this assignment in the truth table here and that would satisfy the dnf but then we would do an R of uh things like this so again we do something for the fourth row so we would get not x one I'm sorry and X2 and X3 or uh what is it X1 and not X2 and not X3 r x one and X2 and not X3 right so this would be a dnf representation of the same thing and again now the number of terms would be the number of ones in this table which again is four so you get four terms again this is not unique you can find a smaller one and so that's an interesting question by itself all right so final warm-up question now so let's look at the satisfiability problem so so far the certifiability problem we've been given the input as a CNF What If instead the input were given as a dnf what would be ah so what do you think about the satisfiability question in such a situation would it be NP complete would it be polynomial time would it be undecidable what do you think foreign okay so we have a few answers in so let's see what the results of the polls say NP complete in polynomial time and undecidable okay so ah okay so this is an interesting one uh it turns out that it's in fact in polynomial time so and it's it's a good thing to understand right so this is a good uh kind of test for yourself and a way to understand that it really depends on how the Boolean function is specified the complexity of the problem changes so from here the point here is that when you're given a function as a dnf yeah a dnf is an R of terms so now to satisfy the dnf it suffices it's equivalent to satisfying one of the terms of the dnf right so now when you're given a dnf which is an order of terms you would go through each of the terms and if I look at a single term right if I look at a term like this there's only one way to set it there is essentially I can check if it's satisfiable or not because the only way to satisfy this term is I have to set x one to zero I have to set X2 to 0 and I have to set x 3 to 1. right that's the only way to satisfy the term and I can check the term is satisfiable or not right just look at it oh I look at the literals okay I set x 1 to 0 x 2 to 0 x 0 to 1. that gives me a satisfying assignment for the term and once I satisfy a single term I satisfy the whole dnf the point is it's an odd of terms so I just need to satisfy one of them so that makes DNS size viability easy so sometimes a term can be not satisfiable right so sometimes a term can be not satisfiable can you tell me a situation a kind of a term which is unsatisfiable yeah right if some variable has to be both true and false you're absolutely right so if you have X1 and not x one for instance and maybe X2 right so this kind of term is unsatisfied so this kind of silly looking term so this is unsatisfiable but every other term is by itself satisfiable so uh you could go through the terms in the DNS and see that you don't see that there's some term that does not have both a variable and its negated form right and if you if you find a term like this you could satisfy it just by setting the variables according to you know how they appear in the term and when you do that you satisfy the whole dnf because the dnf is just an R of things all of these terms yeah and but on the other hand if every term has something like this then of course the dnf is unsatisfied and this is an algorithm that can be implemented efficiently right you don't have to do any sort of exponential search or anything you just go through the terms and see if any of the terms don't have things on this form right and this gives you an algorithm to check if a tnf is satisfied so if you're given a Boolean function as a dnf it is in fact you can check if it's satisfiable in polynomial time that doesn't mean that it's not np-complete right if P equals NP then it could be NP complete but unlike unless P equals NP it's unlikely to be NP complete so in polynomial time would be the most reasonable answer for this but again this gives you an idea of why it's important to look at the format in which a Boolean function is represented and depending on the format the complexity of this problem can change quite a bit okay let me say make sense so um yeah so there is a problem related to DNS which is NP complete and that would be to check if there is an assignment that does not satisfy any of the terms okay it satisfies none of the terms and that's kind of almost like CNF satisfiability so so if you want to come up with a problem for dnfs which was NP complete it would be to find an assignment that satisfies none of the terms and that would be like CNF satisfiability so you can think about that and so now let's kind of get on with the business of the day so this is the satisfiability question and we're going to now show uh hopefully in this lecture that this thing is NP complete and we already started on this path the last time so we looked at a variant of sat okay so here the Boolean function specified as a CNF so we looked at a variant of sound that we call circuit set right where the Boolean function is not specified as a CNF but instead as a circuit so just to recall so what's a circuit so you have your variables here so maybe let's say you have three variables X1 X2 X3 you can negate some of them if you like you can add not Gates maybe I'll add not gets to a couple of them and then you can take combinations with and Gates with or Gates so on to produce something and so at some point of time you say that this is the output gate so this is specified in the circuit you may have more than one output gate but for a circuits at uh for the circuit set problem you look at circuits with a single output gate okay so you have a single output gate like this and now the question is is there an assignment to the underlying Boolean variables that makes this output gate evaluate to true true right so can you set these variables to something I don't know 0 1 0 so that the output gate evaluates to true so that's the circuit set problem and so I should have mentioned this the last time though I uh is kind of remiss of me but you can also have you don't necessarily need to have just variables at the bottom but you can also have uh you know like constants like zero or one so for instance I could also have this we take an R uh with a zero so I could also have things like this that's also allowed it doesn't really make much of a difference you can check that of course taking an r with a zero is not really going to make much of a difference right but it's convenient to have this more General representation for what we're going to do today so let's also allow uh these constants in place of the variables at the bottom okay so a circuit is is in general a directed basically graph that looks like this right and now the question is is there a way of setting the variables to a circuit that makes the output gate in this case there's only a single output gate that makes the single output gate evaluate to one and such a thing is called a satisfying assignment to the circuit and so now you want to know if the circuit is satisfiable if there is a satisfying assignment and of course this problem just like sand right right is in NP because if you give me a satisfying assignment I can actually check that the circuit evaluates to one and what we showed the last time was this that the circuit set it looks like a more General problem than sat because you're given a very compact representation of this Boolean function in this case but nevertheless we showed the last tank that circuit set reduces to Sac it reduces to sat and this was the first example of a polynomial time reduction that we did so what we did was we said okay so start off with the circuit C right and maybe it has a few variables here X1 to x n from here we produce uh a CNF Formula F and the CNF formula was defined on the same set of variables x one to X N but then we also added some more variables here y1 through y m this is like some sort of witness bits that we used the last time and the way we constructed this formula it happened to be the case that if if you have a satisfying assignment to the Circuit here then you can construct a satisfying assignment to the formula by first taking the same assignment to these variables but then adding some assignments to these new variables y one two I so I'm just kind of recalling it a very very high level what we did we won't need the details of this but just kind of good to recall this reduction so you start with the for any satisfying assignment X1 to X N you have a satisfying assignment of the formula by keeping X1 to X N the same but then setting y1 to ym to be suitable values yeah so intuitively these were related to the gates of the circuit so so we had like one y variable for each of these Gates and uh so what you want to do is you want to set these y variables in a way that respects the evaluation of the different Gates of the circuit on this particular satisfying instance so this is roughly the idea so you if you have a satisfying assignment here you can manufacture a satisfying assignment here conversely if you have a satisfying assignment here you can throw away the values of the Y variables and you get a satisfying assignment to the original circuit okay so this gave us a reduction uh from circuit sat to sat that that is a correct reduction in the sense that if the circuit is satisfiable then the formula is satisfiable on the other hand if the formula is satisfiable in the circuit is satisfied so this reduces circuit side to normal CNF select uh so this problem looks more General but we in fact showed that it's at most as hard as CNF said in the sense that there is a polynomial time reduction to it so now to show that CNF sat is NP hard it's just it's sufficient to show that circuit set is NP hard right because now if I have any language in NP if I show that L reduces to Circuit set then we've already seen that if L reduces to something and that something reduces to something else then n directly reduces to that other thing so now I just need to show that every language in NP reduces to Circuit set and that shows that every language in NP reduces to sat and hence that sat is NP hard okay so this is the main thing that remains to do today and so what we are going to do is we are going to kind of uh show how to do this so and the main part will be kind of a technical simulation theorem of circuits by Turing machines but we're going to see how to do that okay so this is where we are so we've shown that circuits we've shown that circuit set reduces to sat we've we've we need to show that circuit set is np-hired and we're all putting things together we'll get what we want all right okay so so now kind of uh set up the stage enough I think I hope and now we can actually come to this last proof of the fact that circuit satisfied and this is a little bit more abstract than anything we've seen so far and the reason for this is that we have to show that any language in NP any language L whatsoever in NP reduces to Circuit set and we don't know much about the language all we know that is that it's an NP so it's kind of a very abstract situation so what do we know about languages in NP we only know this fact at the bottom here is that these languages in NP have a certain verification procedure in polynomial time right so we're going to use this verification procedure very crucially in the reduction okay so that's going to be the only tool that we have and we're going to use it crucially in what follows so how does this thing work so we know that there is verification procedure L Prime which is MP and we are going to use the fact that since it's in P there's a turing machine m which runs in polynomial time right and let's call this polynomial something so let's say Q of n right so you have a turing machine M that's running in Q of n time on inputs of length n and that decides the language L Prime okay and the steering machine is going to give us a handle on the language all right so let's see how to do it so so I want to give you a high level picture of why this should reduce the circuit set okay first let's see that the definition of the language L right in some sense so we know that X is in l if and only if there exists a y of length at most some polynomial in the length of x such that ah X Y is an L Prime but I am going to write that simply as saying that M accepts x y right so you have a turing machine M deciding L Prime and so X Y belonging to L Prime is the same as M accepting X Y so I can rewrite things this way yeah make sense okay on the other hand let's write down the definition of circuit set so C is a circuit C is in circuit set if and only if there exists a satisfying assignment right so there exists again I'm going to use y because it's going to be very similar y such that c on y outputs 1. so that's circuits right and so now you see that these two things are quite similar to each other right so in order to kind of simulate to reduce the problem of checking if x is an L to checking if a circuit is in circuit set what you really need to do is kind of reduce this condition of M accepting x y to a condition that corresponds to a circuit outputting one on some witness y okay so you want to kind of reduce this condition here to this condition here yeah and so what is this condition this is the condition of whether a given turing machine a turing machine is fixed so some fixed program output some string I mean accept some string and this is the question of whether a circuit kind of accepts some string right so in order to do this it's sort of intuitive that what you want to do is you want to simulate whatever the steering machine is doing buy some sort of Boolean circuit and you want to produce a Boolean circuit that sort of simulates exactly what the turing machine is doing and if you can do that you can do this reduction and at a high level this should be possible right because what are Boolean circuits Boolean circuits are things made up of and or and not caves and we know that our computers are made up of Boolean Gates right at a very base level they are they're made up of these logical Gates which are like and Gates or Gates not Gates things of this form right and what is a turing machine a turing machine is just a program so it should be intuitively at a high level clear that you can simulate a program because we do you know we simulate programs on a hardware level with logical Gates so we should be able to simulate the steering Machine by a Boolean circuit okay so that's kind of the idea it should be possible right the only difference is that the way I have defined Boolean circuits they're slightly different from the uh circuits that paid up make up our computers so for one these circuits differ from programs because they can only take a certain number of input bits right so this is a circuit that's set up to take inputs of like three okay take in three input bits it cannot handle input bits or lengths four or five or a hundred so it it can only take input bits for fixed length so in that sense it's a little bit different from a general program and the second sense in which it's somewhat different from a general program is that the circuit cannot execute things like for loops and while Loops right so this circuit you can see that you plug in the bits and then this gate evaluates to something this data values to something etcetera etcetera and you get some value at the output and that's it right whereas a turing machine can go into an infinite Loop important so you can write for loops and while loops and general programs and general Turing missions go to infinite Loops whereas circuits cannot go into Infinite Loops they're sort of fixed so it's so so it's not exactly the kinds of circuits we have in Hardware because in Hardware we have also these things called feedback loop so we can take the result of a computation plug it back into the input and we kind of continue again so Hardware can go into an infinite Loop whereas these kinds of circuits cannot go into an infinite Loop okay so it's sort of a restricted form of these Boolean circuits that we have in Hardware but nevertheless we will show that as long as the running time of the turing machine is bounded by a polynomials right so here we know that there's a polynomial time turing machine it's going to run in queue of n time so we know an upper Bound in the running time okay so we can kind of unfold the computation of a turing machine so that it essentially doesn't have any uh Loops inside of it and then we can simulate it with a circuit like so that's sort of the high level picture all right so let's see uh kind of more precisely what I mean by this yeah so this is it so this is going to be the kind of the engine of the thing which we will see in maybe after the break what we are going to show is that given any language L Prime right here here L Prime doesn't really need to be a verification language but could be any language L Prime in polynomial time given a turing machine M that computes L Prime you can come up with a circuit okay so let's go through this carefully so you can come up with a circuit so there is a circuit CN which simulates exactly what the turing machine does but just on inputs of length n right so so during the turing machine is fixed it's some program that you have in mind and now you want to simulate what this program does just on inputs of length I don't know 10 000 right so you have some input length I just want to do whatever the program is doing but on inputs of length 10 000. and what this theorem guarantees to us is that you can come up with a circuit that does exactly what this computer program does but just on inputs of length 10th house right so it's going to have so three variables it's going to have 10 000 variables but it's going to do exactly what the computer program is doing and the second fact about the circuit is that it's not much bigger right there's a number of gates in the circuit the number of these and or and not Gates is not much bigger than the running time of the computer program right so the computer program runs in time Q of n the turing machine runs in time Q of n then the circuit has a number of gates which is at most the square of Q of n right so it's it's reasonably efficient it's not much worse than the uh what the turing machine is doing okay so if the Turing motion is running in polynomial time the circuit has polynomically medicates and the third Point uh is that the circuit doesn't just come out of thin air you can actually produce this circuit in polynomial time yeah so the final line of this slide is telling you that there is an algorithm there's this algorithm so let's just call it something let's call it a yeah so this algorithm you give it an input number right you give it a number of input bits that you want to work with maybe 10 000. so I'll give it an input and I'll give it to it in unary okay so unit is essentially because we the the running time of the algorithm is going to be polynomial in N so if you want to think of this as a polynomial time algorithm I need to give it its input in unity so I give it a number 10 000 and I ask it give me the circuit that simulates this program on inputs of length 10000. and this algorithm will do it for you so it will produce this circuit C of n right it will produce the circuit that essentially simulates the turing machine on inputs of this length and this algorithm is efficient so a runs in polynomial time yeah so we'll see what the algorithm is it's going to be pretty simple it's essentially going to run in time polynomial in the size of the circuit that we produce that's going to be Q of N squared okay all right so so the meaning of the slide clear it's kind of a mouthful to take in but hopefully you can understand what it's saying at an intuitive level all right so this is going to be the main content of the theorem okay so it's it's it's one of those theorems where the the statement is quite long but the ideas are reasonably clean but once we have this theorem let's see that we can finish the reduction okay so let's see if we can do that then we take a break and then we'll come back and actually do this here so let's see why so now suppose I have this theorem so I can simulate Turing machines by Circuit so now I'm going to do the reduction so now I have an X and I don't know if it's an L or not right and I want to now produce an instance of circuit set so that the circuit the instance is satisfiable exactly when X is in l so let's just write down this condition so X is in L I know exactly when this happens okay and let's write this condition in a slightly more verbose form so there's a witness why and Y can have length at most the polynomial polynomial in the length of X let's call this a x something okay so there is there is a y either of length 0 or there's a y of length one or a y of length 2 etcetera etcetera right in general there could be a y of length I all the way until I guess a y of length P of n so I've just written down this condition here y could have many different lengths but I've written down one condition for each length okay in the polynomial lines so let's just imagine that we are looking at one of these lines so let's say this one yeah I'm looking at whether there is a witness of length exactly I yeah such that M accepts the pair x y right so what does m what does the pair X Y look like so we came up with some sort of encoding scheme for pair some time ago so let's just look at that so M accepting X Y is the same thing as saying M accepts the following string so 0 I guess X1 0 x 2 0 x 3 double 0 x n so that's X right and then we had like a pair of ones or something and then 0 y 1 0 Y 2 0 y i so the question of whether M accepts some pair X Y is the same as the question of whether M accepts some string that looks like this right and what's the length of the string so I guess the length of the string is maybe 2 times n so this has length maybe 2 times n plus 2 plus 2 times I so to know if there is a weakness of length I it's really a question of whether there is some sort of string of length uh this whatever this number is 2N plus 2 plus 2i so that M accepts this type and now I'm going to turn this into a question of whether a circuit accepts something right and the reason I can do this using this theorem is now my input length is sort of fixed so looking for witness of length I I know that these are just inputs of length whatever this is so now I will use my algorithm here to produce a circuit so let's call it C sub 2 N plus 2 plus 2 I right so I will check if there is a circuit which accepts which kind of says the same thing equals one right so question of whether M accepts a string of this form is the same thing as whether a circuit has a satisfying assignment of this form right and this circuit is something that I can produce just from the code of M right this is something that's doable in polynomial time that's what the theorem guarantees to us so we produce this circuit and that's more or less 8 right so we have this circuit so we produce this circuit so let me just draw the circuit abstractly so this is what the circuit looks like right so C 2N plus 2 plus 2i and so it's got a bunch of input bits how many input bits these many so there's Z1 Z2 Z 2 N plus 2 plus 2 I ok so these are the input bits to a circuit so it's all simulating the turing machine on inputs of this length and now I want to know if there is some string of this form that the circuit accepts right so I so among these bits which are the ones I already know I know X1 I know X2 and I know x n right because that's what the reduction starts with it starts with an input X and it wants to know whether X is in the language or not so it knows these X bits it knows where the zeros and the ones are the only thing the circuit doesn't know I mean so the reduction doesn't know is the witness bits and so what the reduction is going to do is it's going to hard code the bit so it already knows so it's called hard code 0 x 1 0 x n one one and the stuff it doesn't know it just leaves as a variable so that's 0 y 1 0 Y 2 0. okay so it's important to understand that these bits are already known right X1 to X N already known y1 to y i are unknown yeah I don't know the witness I want to know if there is a witness of length I I don't know the witness so these are unknown bits and so now let's look at whether the circuit is satisfiable or not the question whether the circuit is satisfiable or not that's exactly the question of whether there's a witness of length I or not because what the circuit is doing is it's simulating the turing machine on this input and the turing machine accepts exactly when the Y bits give me a witness of length I so this is exactly the question of whether there is a witness of length I or not that convinces me that X is in l right so this whole circuit let's give it a name so let's call it d i so d i is a circuit that is satisfiable if and only if there is a witness of length I foreign and the final circuit that you produce so the circuit set instance that we're going to produce here is just going to be you can guess what it is um it's just going to be an R of all these Di's put together so the final circuit C is just going to be d0 or D1 or D2 r d p of okay so it's going to be a gigantic R of all these things and so now uh when is the circuit satisfiable the circuit is satisfiable exactly when at least one of the bis is satisfied but and when is di satisfiable exactly when there is a witness of length I uh for the given input X right and that means that what the circuit is checking is if there is a witness of length at most P of n yeah it's checking if there is a witness of length atmosphere of N and that's exactly the condition for whether X is in L or not right X is in L exactly when there is a witness of length Atmos P of n that convinces you that X is an L so that's exactly what this big circuit is checking so this circuit is satisfiable exactly when there's a witness of length that must be a fan so this circuit is satisfiable exactly when X is in the language okay yeah all right you can see that there was a little bit heavy uh so let's uh take a break yeah and uh maybe you can have some time to digest it and if you have any questions feel free to come and ask me so let's take a pause and come back in 15 minutes so around 11 15. okay all right okay so uh we're almost done so we're kind of coming to the end of and as I mentioned in the first half of the lecture it all comes down to this kind of simulation of Turing machines by circuits once you can simulate Turing machines by circuits we saw how to do this reduction where you reduce the problem of checking if there's a witness of length I to satisfiability of some circuit and then you take an hour of a giant collection of circuits well giant but it's still polynominally many to construct an instance of circuit set the checks if there is some witness of length at most P of n for the given instance X and that's exactly checking if x is in it like I went through it at a kind of a high level and but it's it's a very good thing to think about this reduction in more concrete terms to kind of understand what's going on so for instance you could ask yourself various questions what are the variables of this circuit right right so so if I were to ask you what are the variables of the circuit that we constructed so what are the variables makes sense so how many variables for instance does this circuit have the one that which is constructed how many variables does D I have the circuit that checks for a weakness of length I I okay great yeah you can just shout out your answer if you know it yeah so uh I variables in the eye and then so there's there's a bunch of variables right so these are zero variables one variable two so that's the number of variables right what about the X variables so it seems like there are n plus I variables here but it's not really n plus I variables because these variables already in node so these are bits that you know so you just plug them in there so this is so it's really y1 to y i that are the variables here so that's one thing to keep in mind and it's also worth thinking about okay how does this so this we've produced an instance of circuit sat here so how does this instance of circuit set depend upon X in what sense did we use x to construct this circuit well the sense in which we used X to construct the circuit is to kind of plug in these hard code these bits of X into the circuit okay that's the only sense in which the instance of circuit set which we produced uses this the instance X that we started with but this is crucial because we are trying to decide if x is in the language or not so it better be the case that the instance of circuits that we produced depends on X and so okay so just this is all a little bit abstract so if you try to think about kind of concrete questions about this instance that we produced then I think it will help you hopefully understand this better all right so that was uh all I wanted to say about this second phase that we uh just uh discussed so now let's get to the simulation so this is also one of these things that's a little bit abstract but at a high level it makes a lot of sense so we discussed intuitively why it's true right circuits after all are the computational models are sitting inside our computers and of course they should be able to simulate Turing machines so it's intuitive but here you will really see uh and the power of using turing machine so it's sort of so far it's not clear why we're using Turing machines as a model of computation and it really makes our life simple when we try to do what we're going to do here okay so again the problem with simulating a general computer program by a circuit is that a circuit is kind of an acyclic graph so it cannot do things like while loops and for loops and things like that and so we are going to get around that by kind of unfolding the computation of our program in this case our program is a turing machine right and what what we know about Turing machines is that they put all their data in some sort of tape right so we put here so there's this infinite tape here right and so now I'm just looking at some turing machine running on input of length n maybe so let's put the input here so let's say X1 X2 x n and the turing machine starts with these blank symbols the other places okay and initially the head is scanning the first cell of the input okay so this is what the turing machine looks like in the beginning but now the turing machine at any point of time what it's going to do is is that the what's on the tape is going to evolve according to the rules of the turing machine right right so the next step the turing machine is going to do something else so it's going to look at what's in this cell and based on what's in the cell and the code of the turing machine maybe this thing changes a little bit maybe it becomes some X1 Prime maybe the head goes to the second place accent something like this right and this continues and what we know is that this turing machine is running in polynomial time so it's running in for Q of n steps and input of length n so at the end of Q of n steps so after few of n steps the turing machine is going to end up in a state well it's either accepted the input or rejected the input right and with some sort of data on its tape ok so what we are going to do is we're going to kind of try to simulate the turing machine by simulating the contents of its tape the stuff and the states of the turing machine which are of course also important right so maybe I should put in the state here so at time T equals 0 it's in the start state and then at time T equals one it's in some other state maybe state something else state let's call it maybe a goes up here and at time T equals some capital T which is this Q of n uh it's in it's in some state state may be either accept or reject and we want to understand what that state is in order to understand the Turing machines accepted or rejected okay and we are going to get a circuit that essentially simulates all this information so it simulates what the it kind of computes what the uh States or turing machine at various points are and what the data or the tapes at each of these points okay so we're going to have gates in the circuit for each of these quantities and we're going to compute each of these quantities loading all right so this is the high level idea but there are a couple of problems with this high level idea and one of the problems is that the tape seems to be an infinite amount of information right is infinitely long so it seems to be an infinite amount and The Circuit by its very nature is finite it cannot compute more than a finite amount of information so the way we're going to fix that is to Simply say this turing machine is running only for T steps right Q of n steps so it cannot we know when it starts and at each step it can only move by one one cell so it cannot go more than T steps in either direction of where it started right so though this table or Tableau as it's called Uh looks infinite we can kind of chop it off into a finite part right so we go at most Q of n steps in either direction and we know that what's outside of this window is always going to be filled with blank symbols and we don't need to worry about it so we don't need to simulate that part we just need to simulate what's going on in here all right so this finite part of the tip simulated over Q of n steps so that's kind of called the Tableau and what we are going to do is we're going to simulate everything that goes on in here what's going to be on any cell at any given point of time in one of these steps what's the state of the turing machine where is the head of the turing machine so all this stuff and this is going to be simulated by a circuit and when a circuit can simulate all that at the end it will be able to tell when the turing machine is accepted or not yeah does it make sense at a high level so if you look at the size of this Tableau right it's got Q of n rows right and the number of columns is something like 2 times Q of n okay so size of this whole Tableau is Q of N squared right which is going to be the size of the circuit that we come up with so that's why the size of the circuit is going to be Q of N squared and not Q of n because we're going to have to simulate something for each cell in this big w okay so this is how we are going to get around the fact that a circuit cannot do things like for loops and while loops and things like that we're just going to unfold the computation of a turing machine so that now there are no for Loops or while Loops it's just a sequence of steps these steps of computation and then the turing machine is done and now we can simulate this with a circuit so this is one of the reasons to use Turing machines it's it's kind of hard to see how to do this with a general computer program you can do it in principle you can think about it so if I want to run a Python program for at most 10 000 steps can I eliminate all the four Loops or while Loops that appear in the program you can do it in principle but it's a pain to write down but the turing machine is kind of very nice you can just do this template okay so now we're going to show how to simulate this Tableau with a circuit all right so let's do it so how are we going to what do I mean by simulate well what I'm going to do is I'm going to kind of make a circuit that creates that kind of computes the information corresponding to each cell in this big tableau yeah so I need to say what the information in each cell is so we're going to come up with this notion which we'll call a cell State vector let's just let me just go to the next slide here we have this information so cell State Vector it sort of encapsulates for every cell what's the information content of this cell okay so what's the information contact us so what's the information content in a given cell well what I want to know when I'm looking at a certain cell is I want to know what's the symbol in the cell definitely that I want to know I want to know what's stored in the Cell at that point yeah another thing I might want to know is I might want to know if the head of the turing machine is scanning that cell or not right so if I look at this cell at this point the head is scanning it and this cell is not being scanned by the header turing machine and this is important right because it depends depending on whether the health is scanning or not the contents of the cell can change at the next time step so it's important to know whether the head is scanning the cell or not so that's another bit of information I want to keep track of so let's call it the head bit right so there's just a single bit that's either zero or one and tells me if the head is scanning this cell at this time step or not yeah and finally I also want to know if the head is scanning the cell yeah if it happens with an SL what's the state of the turing machine yeah of course if the heat is not scanning the cell then the state part is irrelevant but if the head happens to be scanning the cell then what's the state are doing machine at this point okay so all of this I'm going to just encode in binary and that's going to be the cell State Vector of this particular cell in the tableau so so the number of symbols of the turing machine you know so so what's what's a simple the symbol uh is kind of the turing machine has an alphabet so let's say it has 0 1 and the blank symbol so now this symbol is going to encode at every stage is it zero one of the bank symbol so it could be zero zero maybe that stands for zero zero one or maybe ah one zero so let's say this is the blank symbol okay so we encode the whole thing in binary so the symbol maybe Takes Two Bits to encode right and the head bit is just a single bit so that's either zero or one and the state of the turing machine well maybe the turing machine has I don't know a hundred States so if it's 100 States that's kind of what is it seven bits to encode 106. so you just encode it right so this is the state but in binary okay so if you have a turing machine with a with a certain number of states and a certain number of symbols so you get a cell State Vector of a certain length and the important thing to observe about this is that the length of this vector is a constant a constant in the sense that it's independent of the length of the input to the turing machine so the length of the input rotating machine is n but the length of cell State Vector just depends on the turing machine itself it just depends on how many symbols the turing machine uses uh and how many states it has right it has nothing to do with the length of the input so this is a constant so the length of this is some constant let us say some number s or something okay independent of the length of the input it's just dependent on the turing machine it's it just depends on the code of the tuning machine does it make sense so that's the cell State vector and now we're going to come up with a circuit which computes the cell State vectors of every given cell in this whole tableau and so let's see how to do it so the easiest case is when we're looking at the bottom the sort of the first uh that time step T equals zero we're looking at the bottom row of this tableau so let's look at what the cell State vectors might be okay so let's start with the one where maybe you have the head scanning the cell right so what's the cell State Vector of this right so I need to encode what's the symbol so symbol is going to be so X1 that's going to be either 0 or 1 depending on X1 right and let's assume that these are the three symbols in our turing machine right so there could be more but we'll handle them in the same way let's say this is here zero or one so they're going to put in so I guess if X1 was so let's say this this encodes 0 this encodes one and the last one is blank so what's the cell State Vector of this right so it's not blank so the first bit is zero and the second bit depending on X1 if X1 is 0 it's 0 x 1 is one that's one that's okay and then what about the what about the head bit well we know the head bit is right because we know that the head is scanning this particular cell at time step T equals zero so the head bit is one so it's one and finally I know the state at this point of time the state is the start state so I just encode the start state right so whatever the start state is so let's say the start status okay let me just write start State here that's not good okay so that's the cell State Vector of this cell at time step T equals zero right the bottom cell in the template let's do the next one the next one is similar so it's 0 and X2 right but the head is not scanning the cell so the head is Hit Bit is zero and if the head is not scanning the cell then it really doesn't matter what the state we put there is so we just maybe put in a bunch of zeros so that's a cell State Vector of that cell yeah it doesn't make sense okay so let's let's try one more let's come to the left here so let's say we have the cell State vector or the blank symbol to the left of the input so what's that going to look like so you're going to have the the symbol is a blank symbol so we encode that to the one and the zero and the head is not scan into cell so that's a zero and if the head is not scan itself it doesn't really matter what the state is we just put in a bunch of zeros Maybe okay so that's a sensitive Vector on the left and you can see how to construct all of these cell State vectors to the bottom row right it's just this and this you can kind of compute think of as a circuit it's a very silly it's a circuit which just has a bunch of constants right one zero zero zero zero and then zero and then you have some variables here x one get rid of this so it's a very silly circuit it's just a from 0 x 1 1 and then whatever encodes the start state and then again 0 so that's this one here X2 so okay so this circuit it's a very kind of stupid circuit right this circuit where every gate is either 0 1 or just a variable the gates of this circuit encode the cell State vectors for the bottom row and now what we are going to do is compute the cell State vectors of the next row based on the cell State vectors at the bottom row yeah and we're going to continue this process until we get the cell State vectors at the top so let me just show you how to go from the cell State Vector of the bottom row to a cell State Vector of the row above so let's do one row about yeah and this is the second place where the choice of a turing machine is really useful so let's assume that we want to compute this cell statement okay so if you want to compute the cell State vector I claim that it's sufficient to look at these three cell State vectors over here to compute this hence State vector because what would I want to do to compute this instant Vector I would want to know the symbol here is and a symbol here is the same as the symbol here right or maybe the turing machine was scanning this cell and then it after scanning the cell it decided to change this symbol do something else right so it's either the same thing as the symbol here or the head the head bit here was one and maybe depending on the code of the turing machine the cell changed right so the symbol bit the simple bits of the cell State Vector just depend on the bits here right so they kind of all of this stuff influences what goes into the symbol bits here so that's the symbol bits and now if I look at the head bit of the cell State Vector the head bit well I need to know if the head is scanning this cell or not right and to know that I need to know it could it could be the case that the head was scanning this bit right and depending on what it saw it decided to move right or maybe the head was scanning this bit and depending on it so you decide to move left and that's essentially the only way this head bit could be one right the only way the head could be scanning this cell at this point of time is if in the previous at the previous time instant it was scanning one of the adjacent cells and it decided to move in the direction of this cell that's the only way this head bit would be one so knowing so deciding if this particular head bit is going to be one sort of depends just on the information that's in these three cells over here in fact just in this cell and this cell it just depends on these two sense and finally what state am I well what state I'm in again depends on whether I was in one of these cells here so if the head bit is zero it doesn't really matter but if the head bit is one it meant that the head was in one of these cells here and then depending on what it saw which state did it go to so that's sort of what influences what state it's going to be in here right so the two the actions of a turing machine are extremely local and this is what is showing up very crucially in this proof the turing machine just looks at what it's doing at this particular looks at what's the contents of this particular cell and depending on that it decides to go either one step to the left one step to the right so it's sort of very very local yeah and therefore the cell State Vector corresponding to one side in the Tableau just depends on three stealth State vectors in the previous row so these are the only three vectors that sort of influence what's going on in the cell State Vector above right so every bit here is a function of just these three times as many bits okay so each of these cell State vectors contains s many bits so every bit here is a function of just three times as many bits it's some sort of fixed Boolean function of these three times as many bits and this is for us s is just a constant right independent of the length of the input so it's some Boolean function of a constant number of bits and you've seen how to write every Boolean function of a constant number of bits as a dnf or a CNF or whatever right so we just take whatever this function is every bit here we write it it's some Boolean function of these s bits so we can write it as a CNF or a dnf of the underlying three s bits right it doesn't really matter how you write it it's a constant sized Boolean function so you can hard code it into your reduction into the the into the algorithm that produces the circuit right so it's just some fixed circuit so every time the algorithm has to produce a cell State Vector for each of these bits it just puts in this hard-coded circuit just plugs it in there and that gives the value of the next sales State vector okay and this is what the algorithm is going to do for every single cell State Vector along this row like for every row it's going to look at the three cell State vectors below and it's going to just plug in the circuit that computes the next cell State Vector given the previous cell three factors I'm just going to plug this in it's going to repeat this process for everything and that's essentially it so so for each of these cells you produce a little circuit that kind of computes the cell State Vector at this given the cell State vectors below that produces all the cell State vectors in this row then you have another circuit that does it for the next row another circuit that is for the next row and so yeah and so the fact that's being used again crucially is this locality of Turing machines right so it's a it's like a turing machine the the way a turing machine evolves is highly local it depends only on a constant amount of information at each time step uh to see how the next cell at that point at that time step is going to evolve and since this only depends on a constant amount of information we know that any function that depends on me on a constant number of bits can be written as a circuit the circuit is exponential in the number of bits that we use but in this case the number of bits we use are only a constant so the size of the circuit is just a constant yeah and we can kind of hard code it inside the procedure that's producing the circuit does this make sense okay that's essentially the whole construction yeah it's a it's a little bit abstract but I hope it's reasonably clear so you start off with these cell State vectors at the bottom right and we described what these cell State vectors are they're very very simple circuits and then using these cell State vectors and this fact that the computation of a turing machine is local you construct the cell State vectors of each of the next few rows and you keep going until you have the cell State vectors of all the rows of all the cells on top right and let's just imagine that we have the cell State vectors of the top row right all the cells in the top row now I want to know if the turing machine accepts or not right and how would I do that well that's fairly simple so let's let's imagine that this is the top row instead so let me just draw the top row so let me look at a single cell State vector so I would know that the turing machine has accepted if on the top row the head bit here is one right so that means the head is scanning the symbol and I'm in the accept state right then I know the turing machine has indeed accepted so if I see this configuration in any cell State Vector in the top row then I know the turing machine is accepted right otherwise the turing machine has not accepted and since it's already finished must have rejected so I can look at each cell State Vector on the top row and see if it looks like this right so I can come up with a little Boolean circuit that says one if the cell State Vector looks like this and 0 if the sensitive Vector doesn't look like this right and that's what these little Boolean circuits on top of this circuit are doing these circuits are called f up here the row just below a so they're all checking if the cell State Vector on the top row kind of looks like this there's one for every single cell State Vector so we're constructing these Boolean circuits and the final thing we need to do to do in all of all these things together to check if the turing machine is actually accepted so we need to do an R of all these little circuits and that will tell us if the turing machine is accepted okay so yeah this picture or maybe looks a little complicated but I hope uh you know make sense what's going on all right so that essentially tells us how to simulate a turing machine on inputs of a given length by a circuit and we've already seen how to use this fat in order to reduce any given language in NP to Circuit send so putting things together we've essentially shown that circuit set is NP higher and of course since circuit set reduces to side sat is also NP hard and it will be completed so uh kind of a so this theorem is a little bit abstract but I highly encourage you to go back and look at it because kind of understanding it is very rewarding I think and it's a it fundamentally tells you what NP is all about so highly recommend going back and taking another look at this to check that you understand all the details okay so that's it so that's the most apps that we are going to do uh and all this so now we have our first NP complete problem right so we have sand which is and now starting from sat as a base we are going to reduce to many other problems uh many of these have to do with graphs some of these have to do with numbers and optimization right so we'll show that all sorts of other problems are NP complete by starting with this one basic problem yeah so the rest of it is going to be very concrete now the advantage is we have sat that's one problem that we really uh at least it's easy to understand relatively easy to understand and so from now uh we'll be working with this concrete problem and reducing it to other things to show a bunch of other things yeah and that's going to be the focus of the next part of the course so so in the very next lecture we're going to see more about site or the particular problem set what cases of heart what cases are easy etc etc and then from then on we'll start looking at uh more reductions okay looks like that's my last slide actually all right so that's all I have so let's stop here for the day and so I guess next week is off uh for Easter so have a great Easter vacation uh so we'll see when you're back and we'll kind of continue with this business of uh NP complete this thanks
    </p>
  </body>
</html>

